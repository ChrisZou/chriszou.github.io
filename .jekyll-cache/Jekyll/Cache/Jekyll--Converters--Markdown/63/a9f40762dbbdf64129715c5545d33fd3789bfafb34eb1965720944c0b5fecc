I"<p><a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a> is a gem aimed at replacing Fixtures. If you wonder that, take a look at <a href="http://www.dan-manges.com/blog/38">whatâ€™s wrong with fixtures</a>.</p>

<h3 id="1-add-factory_girl_rails-to-your-gemfile">1. Add <code>factory_girl_rails</code> to your Gemfile</h3>

<pre><code>group :test, :development do
    gem 'factory_girl_rails'
end
</code></pre>

<h3 id="2-add-to-your-specrails_helper-config-block">2. Add to your spec/rails_helper config block:</h3>

<pre><code>RSpec.configure do |config|
  #  Other config code
  config.include FactoryGirl::Syntax::Methods  # Add this line
end
</code></pre>

<h3 id="3-define-factory">3. Define factory</h3>
<p>In <code>spec/factories.rb</code> or <code>test/factories.rb</code></p>

<pre><code>FactoryGirl.define do
	factory :user do
		username â€˜fooâ€™
		password â€˜secretâ€™
		email {â€œ#{username}@example.comâ€} # define value dynamically, pass a block
	end
end
</code></pre>

<h3 id="4-use-the-factory-in-your-spec">4. Use the factory in your spec</h3>

<pre><code>user = create(:user)
user = create(:user, username: â€˜xiaochuangâ€™, password: â€˜xiaochuangchuangâ€™)  # Override the default value.
user = build(:user)  # Will not save to database, faster than create
</code></pre>

<h3 id="5-tips-and-tricks">5. tips and tricks</h3>

<h4 id="1-use-sequence-in-model-field">1. use sequence in model field</h4>
<p>Say your user model has a validation of uniqueness for the attribute <code>username</code>, then if you call <code>create(:user)</code> multiple times without passing in the <code>username</code>, youâ€™ll get an error. In this case, you can use <code>sequence</code> to auto generate username for you.</p>

<pre><code>factory :user do
	sequence(:username) {|n| â€œuser#{n}â€}
end
</code></pre>

<p>Now everytime you <code>create(:user)</code> will return a user with a different username in the form: user0, user1, user2â€¦</p>

<h4 id="2-use-associations">2. Use associations</h4>
<p>Assume you have a Post model that references to a User.</p>

<pre><code>factory :user do
	username â€˜xiaochuangâ€™
	password â€˜xiaochuangchuangâ€™
end

factory :post do
	title â€˜A new postâ€™
	user #Yes, itâ€™s just that simple.
end
</code></pre>

<p>However, the above usage assume that the user field is name <code>user</code>, if not, you can use <code>association</code> to customize the behavior.
<code>association :author, factory: :user, username: â€˜xiaochuangâ€™</code></p>

<h4 id="3-nested-factory">3. Nested factory</h4>
<p>Say your user model have an attribute called <code>admin</code>, this is used frequently and you donâ€™t want to pass in the admin attribute very time. In this case, you can use a nested factory:</p>

<pre><code>factory :user do
	username â€˜xiaochuangâ€™
	password â€˜xiaochuangchuangâ€™
	admin false

	factory :admin do
		admin true
	end
end
</code></pre>

<p>In your spec, you can just <code>create(:admin)</code> to create a user that set the <code>admin</code> to <code>true</code>.</p>

<h4 id="4-use-build-instead-of-create-if-possible">4. Use build instead of create if possible.</h4>
<p>By using <code>create(:model)</code>, you create the model instance and save if to the database. In many cases if you donâ€™t have to save it the the database, you can use <code>build(:model)</code>. This will build an instance but wouldnâ€™t save to the database, which makes it a little bit faster. <br />
And also, in many cases you if you can just <code>Model.new</code>, you can bypass factories at all, which is even faster.</p>
:ET
I"dQ<p>相信写Android的，写Java的人应该都听说过RxJava这个革命性的东西了，很多人也了解这个东西怎么使用。网上也有很多优秀的介绍性的文章，如果你还不了解这个东西，或者是不熟悉它的用法的话，我会建议先看<a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">这个系列</a>的文章，然后再看<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">这篇</a>。尤其是后者绝对强烈推荐，其实我个人对RxJava的看法，刚开始只是觉得这个东西写起来语法非常简洁，非常优雅，可以在很大程度上面减少一些外部变量的使用，非常Functional。但是等到我看了那篇文章以后，我才发现，我只是发挥了RxJava不到一成的功力，获得了它不到一成的优点。它还有那么强大的力量，隐藏在冰山水下。另外，国内也有广受好评的<a href="https://github.com/rengwuxian">扔物线</a>写的<a href="http://gank.io/post/560e15be2dca930e00da1083">给Android开发者的RxJava详解</a>。这些足够让你对RxJava有一个比较深入的了解，此外，<a href="https://github.com/rengwuxian">扔物线</a>的文章也有一定程度的原理讲解和源码分析，可谓真正的深入浅出。</p>

<p>Anyway，这里我们就不介绍RxJava的用法和特点了，我们简单看看它的源代码。</p>

<p>先看第一部分，Observable的创建。现在大部分介绍RxJava的文章、尤其是介绍RxJava在Android上面的使用的文章，都往往会结合第三方的library，比如<a href="http://square.github.io/retrofit/">Retrofit</a>。里面介绍Observable的使用方式是通过Retrofit的返回结果来获得一个Observable，再操作这个Observable。这容易给我们一种错觉，就好像我们自己从来不用，也不能创建Observable一样。然后其实不是这样的，我们完全可以自己创建Observable。常见的创建Observable的方式有以下几种：</p>

<ol>
  <li><code>Observable.just(...)</code><br />
比如：</li>
</ol>

<pre><code class="language-java">Observable.just("xiaochuang"); //Create an Observable that has only one item: "xiaochuang"
Observable.just("xiaochuang", "handsome"); //Create an Observable that has 2 items: "xiaochuang" and "handsome"
Observable.just("xiaochuang", "is", "handsome"); //Create an Observable that has 3 items: "xiaochuang", "is" and "handsome"
//...you can pass in up to 10 items
</code></pre>

<ol>
  <li><code>Observable.from(an_array_or_iterable);</code><br />
比如：</li>
</ol>

<pre><code class="language-java">Observable.from(new String[]{"xiaochuang", "is", "handsome"});  //Create an Observable that get data from an array

List&lt;String&gt; items = new ArrayList&lt;&gt;();
items.add("xiaochuang");
items.add("is");
items.add("handsome");
Observable.from(items);  //Create an Observable that get data from the List "items"
</code></pre>

<ol>
  <li><code>Observable.create(OnSubscribe);</code><br />
这个就最灵活也最强大了，使用这种方法，你可以把任何东西变成Observable。比如：</li>
</ol>

<pre><code class="language-java">Observable.create(new OnSubscribe&lt;String&gt;() {
            @Override
            public void call(Subscriber&lt;? super String&gt; subscriber) {
                subscriber.onNext("xiaochuang");  //你想要给最终的Subscriber通知什么数据，就在这里调用subscriber的onNext
                subscriber.onNext("is");
                subscriber.onNext("handsome");
                subscriber.onCompleted();
            }
        }); //Create an Observable that emit 3 Strings: "xiaochuang", "is" and "handsome"
</code></pre>
<p>我个人使用这种方式的常见场景，就是把现有的基于<code>Callback</code>的API转换成Observable的形式，比如，你有如下的网络请求方法：</p>

<pre><code class="language-java">public class UserModel {
    public void loadUsers(Callback callback) {
        //...
    }
    public interface Callback {
        void onSuccess(List&lt;User&gt; users);
        void onFailure(int code, String msg);
    }
}
</code></pre>
<p>Client使用这个<code>UserModel#loadUsers</code>的时候，必须传进来一个<code>Callback</code>，如果你想添加一个返回Observable的<code>loadUsers()</code>方法，可以使用这里说的<code>Observable.create()</code>方法来创建一个Observable：</p>

<pre><code class="language-java">public class UserModel {
  public void loadUsers(Callback callback) {
    //...
  }

  public Observable&lt;List&lt;User&gt;&gt; loadUsers() {
      return Observable.create(new OnSubscribe&lt;List&lt;User&gt;&gt;() {
          @Override
          public void call(final Subscriber&lt;? super List&lt;User&gt;&gt; subscriber) {
              loadUsers(new Callback() {
                  @Override
                  public void onSuccess(List&lt;User&gt; users) {
                      if (subscriber.isUnsubscribed()) return;  //这里要记得判断是否unsubscribe了

                      subscriber.onNext(users);
                      subscriber.onCompleted();
                  }

                  @Override
                  public void onFailure(int code, String msg) {
                      if (subscriber.isUnsubscribed()) return;  //这里要记得判断是否unsubscribe了

                      subscriber.onError(new RequestFailureException(code, msg)); //这里的RequestFailureException是自己定义的一个Exception，封装了return code和error msg等信息
                  }
              });
          }
      });
  }

  //Callback interface definition
}
</code></pre>

<p>下面，我们来看下这几种方式创建Observable的源代码。<br />
首先是<code>Observable.just()</code>这种方式。从使用的角度来看，好像一个参数的<code>just()</code>和多个参数的<code>just()</code>没什么区别，但是看代码以后你会发现，他们的还是略有不同的：</p>

<pre><code class="language-java">public final static &lt;T&gt; Observable&lt;T&gt; just(final T value) {
    return ScalarSynchronousObservable.create(value);
}

public final static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2) {  
    return from(Arrays.asList(t1, t2));  //其它多个参数的just方法也是类似的，先变成List，然后调用from(List);
}


</code></pre>
<p>对于只有一个参数的<code>Observable.just()</code>，调用了<code>ScalarSynchronousObservable.create()</code>，同时将传给<code>just()</code>的value传给了 <code>ScalarSynchronousObservable.create()</code> 它的代码如下：</p>

<pre><code class="language-java">public final class ScalarSynchronousObservable&lt;T&gt; extends Observable&lt;T&gt; {
    public static final &lt;T&gt; ScalarSynchronousObservable&lt;T&gt; create(T t) {
        return new ScalarSynchronousObservable&lt;T&gt;(t);
    }
}
</code></pre>

<p>它只是直接调用 <code>ScalarSynchronousObservable</code> 的构造方法，把传入的这个value传给这个构造方法，创建了一个 <code>ScalarSynchronousObservable</code> 对象。再来看看 <code>ScalarSynchronousObservable</code> 的构造方法：</p>

<pre><code class="language-java">public final class ScalarSynchronousObservable&lt;T&gt; extends Observable&lt;T&gt; {
    private final T t;

    protected ScalarSynchronousObservable(final T t) {
        super(new OnSubscribe&lt;T&gt;() {
            @Override
            public void call(Subscriber&lt;? super T&gt; s) {
                s.onNext(t);
                s.onCompleted();
            }
        });
        this.t = t;
    }
</code></pre>

<p>可以看到，它只是<code>new</code>了一个 <code>OnSubscribe</code> 对象，然后传给父类的构造方法，同时将传入的value保存起来。<br />
也就是说，最终，这种方法是调用了Observable的构造方法，传给了一个<code>OnSubscribe</code>实例：</p>

<pre><code class="language-java">public class Observable&lt;T&gt; {

    final OnSubscribe&lt;T&gt; onSubscribe;
    protected Observable(OnSubscribe&lt;T&gt; f) {
        this.onSubscribe = f;
    }
}
</code></pre>

<p>这个构造方法做的事情很简单，就是把传入的<code>OnSubscribe</code>对象保存起来而已。实事上，这是Observable唯一的构造方法。所以大家可想而知，最后肯定是调到这里来的，接下来我们就看看，每种方式都是怎么最后调到这里来的，以及为什么要这么做。</p>

<p>我知道到这里，你很想知道这个<code>OnSubscribe</code>到底是什么东西，它跟Observable是什么关系，跟<code>Subscriber</code>又是什么关系，跟<code>Observer</code>双是什么关系？但是这是先不讲这个东西。先来证实下我们的结论，那就是，所有的创建Observable的方式最终都是调用了Observable的这个只有一个<code>OnSubscribe</code>参数的构造方法。所以下面我们看看有两个参数的<code>Observable.just(T t1, T t2)</code>;</p>

<pre><code class="language-java">public final static &lt;T&gt; Observable&lt;T&gt; just(T t1, T t2) {
    return from(Arrays.asList(t1, t2));
}
</code></pre>

<p>可见，这个方法的实现是先把这两个参数转化成一个<code>List</code>，然后调用<code>Observable.from(Iterable iterable)</code>;<br />
其它有3个、4个。。。10个参数的<code>just()</code>也是一样的实现，而<code>Observable.from(Iterable iterable)</code>的实现是：</p>

<pre><code class="language-java">public final static &lt;T&gt; Observable&lt;T&gt; from(Iterable&lt;? extends T&gt; iterable) {
    return create(new OnSubscribeFromIterable&lt;T&gt;(iterable));
}
</code></pre>

<p>这里是实现是，用传入的<code>iterable</code>创建了一个 <code>OnSubscribeFromIterable</code> , 然后调用<code>Observable.create(OnSubscribe onSubscribe)</code>; 从这里我们知道，<code>OnSubscribeFromIterable</code>应该是实现了<code>OnSubscribe</code>这个<code>interface</code>的一个concrete class。看定义：</p>

<pre><code class="language-java">public final class OnSubscribeFromIterable&lt;T&gt; implements OnSubscribe&lt;T&gt; {

    final Iterable&lt;? extends T&gt; is;

    public OnSubscribeFromIterable(Iterable&lt;? extends T&gt; iterable) {
        if (iterable == null) {
            throw new NullPointerException("iterable must not be null");
        }
        this.is = iterable;
    }
}
</code></pre>

<p>证实了我们的猜测。再回到 <code>create(new OnSubscribeFromIterable&lt;T&gt;(iterable))</code>，看看<code>create()</code>的代码：</p>

<pre><code>public final static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) {
    return new Observable&lt;T&gt;(hook.onCreate(f));
}
</code></pre>

<p>这里的<code>hook.onCreate(f)</code>的定义如下:</p>

<pre><code>public abstract class RxJavaObservableExecutionHook {
    public &lt;T&gt; OnSubscribe&lt;T&gt; onCreate(OnSubscribe&lt;T&gt; f) {
        return f;
    }
}
</code></pre>

<p>这里，<code>onCreate()</code>的具体实现其实不重要，重要的是它的返回值，一个<code>OnSubscribe</code>。所以说，这种创建Observable的方法，最终也是调用到了Observable只有一个<code>OnSubscribe</code>的构造方法。</p>

<p>剩下的<code>Observable.from(Iterable iterable)</code>，我们分析过。而<code>Observable.from(T[] array)</code>:</p>

<pre><code>public final static &lt;T&gt; Observable&lt;T&gt; from(T[] array) {
    return from(Arrays.asList(array));
}
</code></pre>

<p>可见只是调用了<code>Observable.from(Iterable iterable)</code>。最后的<code>Observable.create(OnSubscribe)</code>我们也分析过。</p>

<p>综上所述，所有的创建Observable的方法最终都会调到Observable唯一的构造方法：</p>

<pre><code>public class Observable&lt;T&gt; {
    final OnSubscribe&lt;T&gt; onSubscribe;

    protected Observable(OnSubscribe&lt;T&gt; f) {
        this.onSubscribe = f;
    }
}
</code></pre>
<p>对于<code>Observable.just(T t)</code>来说，是通过<code>ScalarSynchronousObservable.create(T t);</code> <code>ScalarSynchronousObservable</code> 调用 <code>ScalarSynchronousObservable</code> 的构造方法，<code>ScalarSynchronousObservable</code>再通过<code>super</code>去调<code>Observable</code>的构造方法。而对于<code>Observable.just(T t1, T t2, ...)</code>、<code>Observable.from(T[] array)</code>、<code>Observable.from(Iterable iterable)</code>都会调到<code>Observable.create(OnSubscribe onSubscribe)</code>，然后<code>Observable.create(OnSubscribe onSubscribe)</code>再调到Observable的构造方法。
它们之间的调用关系图如下：</p>

<p><img src="http://jietu-10024907.file.myqcloud.com/lzuqmlbvitvrdebqxlpfinnqclfactct.jpg" alt="" /></p>

<p>不同的创建方法，有不同的<code>OnSubscribe</code>的实现。对于<code>Observable.just(T t)</code>来说，是在<code>ScalarSynchronousObservable</code>的构造方法里面自己new的一个<code>OnSubscribe</code>：</p>

<pre><code>protected ScalarSynchronousObservable(final T t) {
    super(new OnSubscribe&lt;T&gt;() {
        @Override
        public void call(Subscriber&lt;? super T&gt; s) {
            s.onNext(t);
            s.onCompleted();
        }
    });
}
</code></pre>
<p>对于<code>Observable.just(T t1, T t2, ...)</code>、<code>Observable.from(T[] array)</code>、<code>Observable.from(Iterable iterable)</code>来说，使用的是<code>OnSubscribeFromIterable</code>：</p>

<pre><code>public final class OnSubscribeFromIterable&lt;T&gt; implements OnSubscribe&lt;T&gt; {

    final Iterable&lt;? extends T&gt; is;

    public OnSubscribeFromIterable(Iterable&lt;? extends T&gt; iterable) {
        if (iterable == null) {
            throw new NullPointerException("iterable must not be null");
        }
        this.is = iterable;
    }

    @Override
    public void call(final Subscriber&lt;? super T&gt; o) {
        final Iterator&lt;? extends T&gt; it = is.iterator();
        if (!it.hasNext() &amp;&amp; !o.isUnsubscribed())
            o.onCompleted();
        else
            o.setProducer(new IterableProducer&lt;T&gt;(o, it));
    }
}
</code></pre>

<p>那么现在剩下的唯一的问题是，<code>OnSubscribe</code> 到底是什么样的一个东西？看代码：</p>

<pre><code>/**
 * Invoked when Observable.subscribe is called.
 */
public interface OnSubscribe&lt;T&gt; extends Action1&lt;Subscriber&lt;? super T&gt;&gt; {
    // cover for generics insanity
}

/**
 * A one-argument action.
 */
public interface Action1&lt;T&gt; extends Action {
    void call(T t);
}
</code></pre>

<p>可以看到，<code>OnSubscribe</code> 是一个interface，继承自<code>Action1</code>，而<code>Action1</code>又继承自一个<code>Action</code>。在RxJava里面，一个<code>Action</code>可看作一个类似于<code>Runnable</code>的接口定义，<code>Action</code>有11个子类，分别是<code>Action0</code>、<code>Action1</code>。。。<code>Action9</code>、<code>ActionN</code>，他们都只有一个 <code>call()</code> 方法，这个<code>call()</code>方法的参数个数在这几个<code>Action</code>的子接口里面分别是0个、1个。。。9个和不限个数的多个。</p>

<p>话说回来，<code>OnSubscribe</code> 继承自<code>Action1</code>，它只有一个<code>call(T t)</code>方法，通过泛型的声明可以看出，<code>OnSubscribe</code> 的这个<code>call()</code>方法的参数是一个<code>Subscriber</code>。这个跟我们前面看到的是一样的。我们前面看到，这个类的对象是传给Observable的构造方法，用来构造出一个Observable。那它跟Observable是什么关系呢？通过这个类的doc可以看出，以及Observable的构造方法的doc</p>

<pre><code>public class Observable&lt;T&gt; {

    final OnSubscribe&lt;T&gt; onSubscribe;

    /**
     * Creates an Observable with a Function to execute when it is subscribed to.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; Use {@link #create(OnSubscribe)} to create an Observable, instead of this constructor,
     * unless you specifically have a need for inheritance.
     *
     * @param f
     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called
     */
    protected Observable(OnSubscribe&lt;T&gt; f) {
        this.onSubscribe = f;
    }
}
</code></pre>

<p>可以看出，其实<code>OnSubscribe</code>的作用就是，当用它构造出来的Observable的 <code>subscribe()</code>方法被调用的时候，它的<code>call()</code>方法会被调用。这个可以通过<code>subscribe()</code>方法的源代码得到验证：</p>

<pre><code>public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
     return Observable.subscribe(subscriber, this);
 }

 private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     //...
     // if not already wrapped
     if (!(subscriber instanceof SafeSubscriber)) {
         // assign to `observer` so we return the protected version
         subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
     }
     try {
         // allow the hook to intercept and/or decorate
         hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
         return hook.onSubscribeReturn(subscriber);
     } catch (Throwable e) {
         //...
     }
 }
</code></pre>

<p>关键的一行是 <code>hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</code> 其中 <code>hook.onSubscribeStart(observable, observable.onSubscribe)</code>的实现很简单，</p>

<pre><code>public &lt;T&gt; OnSubscribe&lt;T&gt; onSubscribeStart(Observable&lt;? extends T&gt; observable, final OnSubscribe&lt;T&gt; onSubscribe) {
    // pass-thru by default
    return onSubscribe;
}
</code></pre>

<p>这里直接把传入的<code>OnSubscribe</code>给return了，所以上面的那行代码相当于： <code>onSubscribe.call(subscriber);</code>，同时传给<code>call()</code>方法的<code>subscriber()</code>就是我们在<code>subscribe()</code>的时候传入的<code>subscriber()</code>。(Well, not exactly)，验证了我们前面的结论。最后，再回过头去看前面几种创建Observable方法的<code>OnSubscribe</code>的实现的话，你会发现，他们都是在某个点相应的去调传入的<code>subscriber</code>的<code>onNext()</code>、<code>onComplete()</code>或<code>onError()</code>。这个估计你也猜得到，就是我们为什么<code>subscribe</code>的时候，如果有数据的话，会在<code>onNext()</code>收到数据，<code>onComplete()</code>或<code>onError()</code>会得到调用的原因。</p>

<p>这里有一个比较有意思的点是，为什么要把observable的构造方法设置为protected，然后通过工厂方法来创建？为什么不直接把constructor直接设为public，让外面可以访问到呢？这个其实在<a href="https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683">Effective Java</a>的第一条就讲到了。使用<a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method</a>有以下的好处：</p>

<ol>
  <li>可读性更高: <code>Observable.from()</code>、<code>Observable.just()</code>方法等等除了使用起来更方便之外，可读性也比自己创建自应的<code>OnSubscribe</code>然后传给Observable的构造方法要高很多。</li>
  <li>实现缓存: 不用每次都创建一个新的对象。当然这点在我们看到的例子里面没有相应的应用。</li>
  <li>可以返回子类，方便以后拓展，比如说<code>just(T t)</code>方法返回的是Observable的子类 <code>ScalarSynchronousObservable</code>，而不是Observable本身。</li>
</ol>

<p>此外，我觉得还有个原因就是实现像代码里面的hook这种功能，给你进一步控制Observable创建的过程。比如说在hook里面打log，实现类似decorator pattern的作用等等。</p>

<p>这篇小文简单分析了一下几种创建Observable的方法的源码，当然Observable创建的方法有<a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">很多</a>，这些都算是RxJava的Operators的一部分。但无论是哪种方式，可以预见的是，它们都会构建出一个OnSubscribe对象，然后传给Observable的构造方法。在这个OnSubscribe对象的<code>call(Subscriber subscriber)</code>方法里面，它需要在某个点通过某种方式调用传入的<code>subscriber</code> 的 <code>onNext()</code>，<code>onComplete()</code>或<code>onError()</code>方法。按照这个思路去看其它的Observable创建方法的代码，应该会清楚一些。</p>
:ET
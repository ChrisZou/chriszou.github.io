I"ô<p>Regular expressions are nuts. You have spent lots of time studying them and later when you actually need to write one, you come up with nothing. Thatâ€™s why you need a cheatsheet, like this one.</p>

<h2 id="abbreviations-used-in-this-post">Abbreviations used in this post</h2>

<p>RE for regular expression.      <br />
<code>/regular_expression_content/</code>   regular_expression_content is the text of a regular expression, The two â€œ/â€ is there to indicate the this string is used as a regular expression, rather than a normal string. <br />
<code>&lt;=&gt;</code>   means â€œequalsâ€, or â€œis the same asâ€.  <br />
<code>=~</code>    means perform the match action. For example: <code>/\d+/ =~ â€œhello, 123!â€</code> means match <code>â€œhello, 123!â€</code> against the regular expression <code>\d+</code>.  <br />
<code>#=&gt;</code>   The content after <code>#=&gt;</code> is the result of the matches before it.</p>

<p>Yes, some of them are just Ruby syntax.</p>

<h2 id="normal-text-is-re">Normal text is RE</h2>

<p>Normal string like â€œhelloâ€ is valid regular expression that matches itself(â€œhelloâ€).  <br />
Example:  <br />
<code>â€œHello, my name is Chrisâ€ =~ /name/</code>   #=&gt; â€œnameâ€</p>

<h2 id="character-class">Character class</h2>

<p>A character class is a set of characters inside a square bracket â€œ[]â€: <code>[abcdefg]</code>.  <br />
A character class matches any <strong>single</strong> characters consists of it. So <code>/[abcdefg]/</code> matches any single characters among â€˜aâ€™, â€˜bâ€™, â€˜câ€™, â€¦, â€˜gâ€™.  <br />
You can use â€˜-â€˜ to define a range for a  character class: [a-g], [a-z], [A-Z], [0-9], etc.  <br />
Some  character classes are so commonly used that they made some <em>shortcuts</em> for them:  <br />
.  &lt;=&gt; any character
\s &lt;=&gt; any space character, including â€˜ â€˜, tab and newline character.    <br />
\S &lt;=&gt; any character expect space character(â€˜ â€˜, tab and newline character)  <br />
\w &lt;=&gt; any <em>word character</em>: a-z, A-Z, 0-9, and â€˜_â€™ Some programming languages limit you to define variable or method names using these characters, and this is why(or the result?).  <br />
\W &lt;=&gt; any character except <em>word character</em>.  <br />
\d &lt;=&gt; any number character, aka, [0123456789].  <br />
\D &lt;=&gt; I guess you already know what it means: any character except number character.</p>

<p>Example:  <br />
<code>â€œHello, 123!â€ =~ /\w/</code>     Â  Â  Â  #=&gt; â€œHâ€   <br />
<code>â€œHello, 123!â€ =~ /\W/</code>     Â  Â  Â   #=&gt; â€œ,â€  <br />
<code>â€œHello, 123!â€ =~ /\s/</code>     Â  Â  Â   #=&gt; â€œ â€  <br />
<code>â€œHello, 123!â€ =~ /\S/</code>     Â  Â  Â   #=&gt; â€œHâ€  <br />
<code>â€œHello, 123!â€ =~ /\d/</code>    Â  Â  Â    #=&gt; â€œ1â€  <br />
<code>â€œHello, 123!â€ =~ /\D/</code>     Â  Â  Â   #=&gt; â€œHâ€</p>

<h2 id="anchors">Anchors</h2>

<p>Anchors are characters that specify a position. Commonly known are â€œ^â€ which specifies the start of a line, and â€œ$â€ which specifies the end of a line. Other commonly used anchors are:  <br />
\AÂ  Â  Â   the start of a string  <br />
\ZÂ  Â  Â   the end of a string  <br />
\bÂ  Â  Â   the start or end of a word  <br />
\BÂ  Â  Â   some place other than the start or end of a word.<br />
The difference between \A(\Z) and ^($)? Well, a string may contain several lines.</p>

<h2 id="repetitions-specifier">Repetitions specifier</h2>

<p>*  Â  Â  Â  any times, zero times or more.<br />
+  Â  Â  Â  one time or more<br />
?   Â  Â  Â  zero or one time<br />
{m, n}   Â  Â  Â at lease m times and at least n times<br />
{m, }    Â  Â  Â at lease m times<br />
{,n}  Â  Â  Â  at most n times.</p>

<h2 id="parenthesisegroups">Parenthesise(groups)</h2>

<p>Groups are used for two purpose.</p>
<ul>
  <li>Used to define a unit</li>
  <li>Used to store matching results so that you can refer to them later in the same regular expression</li>
</ul>

<h3 id="use-group-to-define-a-unit">Use group to define a unit.</h3>

<p>Normally, the repetition characters are applied to the single character in front of it.<br />
<code>/hello*/</code>  will match â€œhellâ€, â€œhelloâ€, â€œhellooâ€, â€¦.<br />
the * is applied to the character â€œoâ€ only. How can you specify the repetition to be applied to the whole word â€œhelloâ€? Thatâ€™s where groups comes in:<br />
<code>/(hello)*/</code>  will match â€œhelloâ€, â€œhellohelloâ€, â€œhellohellohelloâ€, â€¦<br />
Another example to use group to define a unit is when using the â€œ|â€ operator.<br />
We can use â€œ|â€ as â€œorâ€ in regular expression. For example, I want to match the word â€œCaptainâ€ or â€œNatashaâ€. Then I can write the regular expression as:<br />
<code>/Captain|Natasha/</code><br />
Yet the problem with <code>|</code> is that it is very greedy. It will regard all the left-side part as a unit and then all the right-side part as a unit. Say you want to match â€œHello Captainâ€ or â€œHello Natashaâ€. You may be tempted to write the regular expression as:<br />
<code>/Hello Captain|Natasha/</code><br />
Yet this will not work. Rather, this regular expression will match â€œHello Captainâ€ or â€œNatashaâ€.  If you want to achieve the expected result, you can use <code>()</code> in it:<br />
<code>/Hello (Captain|Natasha)/</code></p>

<h3 id="used-group-as-a-storage-that-can-be-referenced-later">Used group as a storage that can be referenced later</h3>

<p>Say you want to match a <em>Palindromes</em> string consists of 5 characters, like â€œabcbaâ€. You can write the regular expression as such:<br />
<code>/(\w)(\w)(\w)\2\1/</code></p>

<p>The <code>\1</code> in the regular expression means the matching result of the first part that was enclosed by <code>()</code> in the regular expression. And \2 means the second. <br />
Regular expression count the occurrence sequence of <code>()</code> and put the matching result in \1, \2, etc. So that you can refer to these matching result later in the same regular expression. <br />
Most programming languages also have ways to reference these parts of matching result <strong>after</strong> the match. In Ruby, the <code>match</code> method of regular expression will return a MatchData object.</p>

<pre><code class="language-Ruby">md = /(\d\d):(\d\d)([aApP][mM])/.match('12:50am')  
md[1]   #=&gt; 12  
md[2]   #=&gt; 50  
md[3]   #=&gt; am  
md[0]   #=&gt; 12:50am  (the whole matching result)  
</code></pre>

<p>In some <em>find and replace</em> tools, you can also use \1, \2 etc in the <em>replacing</em> regular expression to refer to the the matching group in the <em>find</em> process.<br />
Say you have a file containing a list of some names:</p>

<pre><code>Steve Rogers  
Natasha Romanova  
Thor Odinson  
Bruce Banner  
...  
</code></pre>

<p>And you want to change the display order to</p>

<pre><code>Rogers, Steve  
Romanova, Natasha  
Odinson, Thor  
Banner, Bruce  
...  
</code></pre>

<p>You can write the following regular expression:<br />
<code>%s/\v(\w+) (\w+)/\2, \1/g</code><br />
The <code>\v</code> is there so that we donâ€™t have to escape the <code>(</code> and <code>)</code> characters, otherwise you have to write as:  <code>%s/\(\w+\) \(\w+\)/\2, \1/g</code>. It just the way vim works in its <code>find and replace</code> tool, rather then regular expressionâ€™s behaviour.</p>
:ET